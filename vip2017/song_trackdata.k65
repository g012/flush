/*
 * TIATracker music player
 * Copyright 2016 Andre "Kylearan" Wichmann
 * Website: https://bitbucket.org/kylearan/tiatracker
 * Email: andre.wichmann@gmx.de
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Song author: 
 * Song name: 
 */


 /* =====================================================================
 * Flags
 * =====================================================================
 */
[
    // 1: Global song speed, 0: Each pattern has individual speed
    TT_GLOBAL_SPEED         = 1,
    // duration (number of TV frames) of a note
    TT_SPEED                = 6,
    // duration of odd frames (needs TT_USE_FUNKTEMPO)
    TT_ODD_SPEED            = 6,

    // 1: Overlay percussion, +40 bytes
    TT_USE_OVERLAY          = 0,
    // 1: Melodic instrument slide, +9 bytes
    TT_USE_SLIDE            = 0,
    // 1: Goto pattern, +8 bytes
    TT_USE_GOTO             = 1,
    // 1: Odd/even rows have different SPEED values, +7 bytes
    TT_USE_FUNKTEMPO        = 0,
    // If the very first notes played on each channel are not PAUSE, HOLD or
    // SLIDE, i.e. if they start with an instrument or percussion, then set
    // this flag to 0 to save 2 bytes.
    // 0: +2 bytes
    TT_STARTS_WITH_NOTES    = 0
]


/* =====================================================================
 * Permanent variables. These are states needed by the player.
 * =====================================================================
 */
var tt_timer=0x80,          // current music timer value
    tt_cur_pat_index[2],    // current pattern index into tt_SequenceTable
    tt_cur_note_index[2],   // note index into current pattern
    tt_envelope_index[2],   // index into ADSR envelope
    tt_cur_ins[2];          // current instrument


/* =====================================================================
 * Temporary variables. These will be overwritten during a call to the
 * player routine, but can be used between calls for other things.
 * =====================================================================
 */
var tt_ptr[2];


/* =====================================================================
 * Initialize music.
 * Set tt_cur_pat_index[2] to the indexes of the first patterns from
 * tt_SequenceTable for each channel.
 * Set tt_timer and tt_cur_note_index[2] to 0.
 * All other variables can start with any value.
 * =====================================================================
 */
inline tt_init {
    tt_cur_pat_index=a=0
    tt_cur_pat_index+1=a=15
    // the rest should be 0 already from startup code. If not,
    // set the following variables to 0 manually:
    // - tt_timer
    // - tt_cur_pat_index[2]
    // - tt_cur_note_index[2]
}


/*
 * =====================================================================
 * TIATracker melodic and percussion instruments, patterns and sequencer
 * data.
 * =====================================================================
 */

/*
 * =====================================================================
 * Melodic instrument definitions (up to 7). tt_envelope_index holds
 * the index values into these tables for the current instruments played
 * in channel 0 and 1.
 *
 * Each instrument is defined by:
 * - tt_InsCtrlTable: the AUDC value
 * - tt_InsADIndexes: the index of the start of the ADSR envelope as
 *      defined in tt_InsFreqVolTable
 * - tt_InsSustainIndexes: the index of the start of the Sustain phase
 *      of the envelope
 * - tt_InsReleaseIndexes: the index of the start of the Release phase
 * - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
 *      the envelope
 * =====================================================================
 */

// Instrument master CTRL values
data tt_InsCtrlTable {
        0x06 0x04 0x0c

}

// Instrument Attack/Decay start indexes into ADSR tables.
data tt_InsADIndexes {
        0x00 0x07 0x07

}

// Instrument Sustain start indexes into ADSR tables
data tt_InsSustainIndexes {
        0x03 0x09 0x09

}

// Instrument Release start indexes into ADSR tables
// Caution: Values are stored with an implicit -1 modifier! To get the
// real index, add 1.
data tt_InsReleaseIndexes {
        0x04 0x0c 0x0c

}

// AUDVx and AUDFx ADSR envelope values.
// Each byte encodes the frequency and volume:
// - Bits 7..4: Freqency modifier for the current note ([-8..7]),
//       8 means no change. Bit 7 is the sign bit.
// - Bits 3..0: Volume
// Between sustain and release is one byte that is not used and
// can be any value.
// The end of the release phase is encoded by a 0.
data tt_InsFreqVolTable {
// 0: bassline
        0x8f 0x8e 0x8d 0x83 0x00 0x80 0x00
// 1+2: lead
        0x87 0x86 0x85 0x75 0x85 0x00 0x83 0x00

}


/*
 * =====================================================================
 * Percussion instrument definitions (up to 15)
 *
 * Each percussion instrument is defined by:
 * - tt_PercIndexes: The index of the first percussion frame as defined
 *      in tt_PercFreqTable and tt_PercCtrlVolTable
 * - tt_PercFreqTable: The AUDF frequency value
 * - tt_PercCtrlVolTable: The AUDV volume and AUDC values
 * =====================================================================
 */

// Indexes into percussion definitions signifying the first frame for
// each percussion in tt_PercFreqTable.
// Caution: Values are stored with an implicit +1 modifier! To get the
// real index, subtract 1.
data tt_PercIndexes {
        0x01

}

// The AUDF frequency values for the percussion instruments.
// If the second to last value is negative (>=128), it means it's an
// "overlay" percussion, i.e. the player fetches the next instrument note
// immediately and starts it in the sustain phase next frame. (Needs
// TT_USE_OVERLAY)
data tt_PercFreqTable {
// 0: Snare
        0x05 0x1a 0x08 0x05 0x05 0x05 0x00

}

// The AUDCx and AUDVx volume values for the percussion instruments.
// - Bits 7..4: AUDC value
// - Bits 3..0: AUDV value
// 0 means end of percussion data.
data tt_PercCtrlVolTable {
// 0: Snare
        0x8f 0xce 0x6f 0x89 0x86 0x83 0x00

}


/*
 * =====================================================================
 * Track definition
 * The track is defined by:
 * - tt_PatternX (X=0, 1, ...): Pattern definitions
 * - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
 *      as index values
 * - tt_SequenceTable: The order in which the patterns should be played,
 *      i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
 *      for all channels and sub-tracks. The variables tt_cur_pat_index
 *      hold an index into tt_SequenceTable for each channel.
 *
 * So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
 * in turn point to pattern definitions (tt_PatternX) in which the notes
 * to play are specified.
 * =====================================================================
 */

/*
 * =====================================================================
 * Pattern definitions, one table per pattern. tt_cur_note_index
 * holds the index values into these tables for the current pattern
 * played in channel 0 and 1.
 *
 * A pattern is a sequence of notes (one byte per note) ending with a 0.
 * A note can be either:
 * - Pause: Put melodic instrument into release. Must only follow a
 *      melodic instrument.
 * - Hold: Continue to play last note (or silence). Default "empty" note.
 * - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
 *      by -7..+7 and keep playing it
 * - Play new note with melodic instrument
 * - Play new note with percussion instrument
 * - End of pattern
 *
 * A note is defined by:
 * - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
 *      and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
 *      defined as:
 *      - 0: End of pattern
 *      - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
 *      - 8: Hold
 *      - 16: Pause
 *      - [17..31]: Play percussion instrument 1..15
 *
 * The tracker must ensure that a pause only follows a melodic
 * instrument or a hold/slide.
 * =====================================================================
 */
[
    TT_FREQ_MASK    = 31,
    TT_INS_HOLD     = 8,
    TT_INS_PAUSE    = 16
]

// b0
data tt_pattern0 {
        0x2f 0x08 0x2f 0x2f 0x08 0x2f 0x34 0x31
        0x2c 0x08 0x2c 0x2c 0x08 0x2c 0x2c 0x08
        0x31 0x08 0x31 0x31 0x08 0x31 0x34 0x31
        0x2b 0x08 0x2b 0x2b 0x08 0x2b 0x2b 0x31
        0x00

}
// b+mel0
data tt_pattern1 {
        0x2f 0x73 0x2f 0x2f 0x73 0x2f 0x34 0x31
        0x2c 0x73 0x2c 0x2c 0x75 0x2c 0x2c 0x73
        0x31 0x73 0x31 0x31 0x73 0x31 0x34 0x31
        0x70 0x73 0x2b 0x2b 0x75 0x2b 0x2b 0x31
        0x00

}
// d0
data tt_pattern2 {
        0x08 0x08 0x11 0x08 0x08 0x08 0x11 0x08
        0x08 0x08 0x11 0x11 0x08 0x08 0x11 0x08
        0x08 0x08 0x11 0x08 0x08 0x08 0x11 0x08
        0x08 0x08 0x11 0x08 0x11 0x11 0x11 0x11
        0x00

}
// d+mel0a
data tt_pattern3 {
        0x5d 0x08 0x11 0x08 0x4e 0x08 0x11 0x08
        0x50 0x08 0x11 0x11 0x51 0x50 0x11 0x08
        0x00

}
// d+mel0b
data tt_pattern4 {
        0x50 0x08 0x11 0x4e 0x50 0x4e 0x11 0x08
        0x4b 0x4e 0x11 0x50 0x11 0x11 0x4e 0x11
        0x00

}
// d+mel0c
data tt_pattern5 {
        0x4e 0x50 0x11 0x08 0x4e 0x4b 0x11 0x50
        0x4b 0x4e 0x11 0x4b 0x11 0x11 0x4e 0x11
        0x00

}
// d+mel1a
data tt_pattern6 {
        0x4e 0x08 0x11 0x08 0x08 0x08 0x11 0x08
        0x4e 0x50 0x11 0x11 0x08 0x08 0x11 0x08
        0x4e 0x08 0x11 0x08 0x08 0x08 0x11 0x08
        0x4b 0x4e 0x11 0x50 0x11 0x11 0x11 0x11
        0x00

}



/*
 * =====================================================================
 * Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
 * Each byte encodes the speed of one pattern in the order
 * of the tt_PatternPtr tables below.
 * If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
 * the even speed and the high nibble the odd speed.
 * =====================================================================
 */

data tt_PatternSpeeds {

}


/*
 * =====================================================================
 * Pattern pointers look-up table.
 * =====================================================================
 */
data tt_PatternPtrLo {
        &<tt_pattern0 &<tt_pattern1 &<tt_pattern2 &<tt_pattern3
        &<tt_pattern4 &<tt_pattern5 &<tt_pattern6
}
data tt_PatternPtrHi {
        &>tt_pattern0 &>tt_pattern1 &>tt_pattern2 &>tt_pattern3
        &>tt_pattern4 &>tt_pattern5 &>tt_pattern6
}


/*
 * =====================================================================
 * Pattern sequence table. Each byte is an index into the
 * tt_PatternPtrLo/Hi tables where the pointers to the pattern
 * definitions can be found. When a pattern has been played completely,
 * the next byte from this table is used to get the address of the next
 * pattern to play. tt_cur_pat_index[0/1] hold the current index values
 * into this table for channels 0 and 1.
 * If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
 * number encoded in bits 6..0 (i.e. value AND %01111111).
 * =====================================================================
 */
data tt_SequenceTable {
    // ---------- Channel 0 ----------
        0x00 0x00 0x00 0x00 0x00 0x00 0x01 0x01
        0x01 0x01 0x01 0x01 0x01 0x01 0x80


    // ---------- Channel 1 ----------
        0x02 0x02 0x03 0x04 0x03 0x05 0x03 0x04
        0x03 0x05 0x03 0x04 0x03 0x05 0x03 0x04
        0x03 0x05 0x06 0x06 0x02 0x02 0x8f

}
